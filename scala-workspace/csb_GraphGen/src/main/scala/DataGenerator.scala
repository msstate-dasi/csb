import java.io.FileWriter

import org.apache.spark.SparkContext
import org.apache.spark.api.python.WriteInputFormatTestDataGenerator

import scala.util.Random

/**
  * Created by justin on 12/5/2016.
  */

import scala.io.Source

object DataGenerator{

  var edgeCnt:            String = ""
var originalBytesStr:     String = ""
var originalIPByteCntStr: String = ""
var connectionStateStr:   String = ""
var connectionTypeStr:    String = ""
var durationStr:          String = ""
var originalPackCntStr:   String = ""
var respByteCntStr:       String = ""
var respIPByteCntStr:     String = ""
var respPackCntStr:       String = ""


  //constructor
  {
    this.edgeCnt =              readFile("EdgeProbability")
    this.originalBytesStr =     readFile("Original_byte_count")
    this.originalIPByteCntStr = readFile("Original_IP_byte_count")
    this.connectionStateStr =   readFile("Connection_state")
    this.connectionTypeStr =    readFile("Connection_type")
    this.durationStr =          readFile("Duration_of_connection")
    this.originalPackCntStr =   readFile("Original_packet_count")
    this.respByteCntStr =       readFile("Resp_byte_count")
    this.respIPByteCntStr =     readFile("Resp_IP_byte_count")
    this.respPackCntStr =       readFile("Resp_packet_count")
  }


  def readFile(fileName: String): String=
  {
   return Source.fromFile(fileName).mkString
  }


    def edgeCount(): Int =
  {
    return generateRandNumFromFileDist(this.edgeCnt)
  }
  def originalByteCount(): Long =
  {
    return generateRandNumFromFileDist(this.originalBytesStr)
  }
  def originalIPByteCount(byteCnt: Long, sc: SparkContext): Long =
  {
    return generateRandNumBasedBytes(this.originalIPByteCntStr, byteCnt, sc)
  }
  def connectState(byteCnt: Long, sc:  SparkContext): String =
  {
    return generateRandStrBasedBytes(this.connectionStateStr, byteCnt, sc)
  }

//  val connectState = generateRandomFromFileConditionalString("Connection_state", Orig_byte_count, sc)
//  val connectType = generateRandomFromFileConditionalString("Connection_type", Orig_byte_count, sc)
//  val Duration = generateRandomFromFileConditional("Duration_of_connection", Orig_byte_count, sc)
//  val OriginalPackCount = generateRandomFromFileConditional("Original_packet_count", Orig_byte_count, sc)
//  val RespByteCount = generateRandomFromFileConditional("Resp_byte_count", Orig_byte_count, sc)
//  val ResIPByteCount = generateRandomFromFileConditional("Resp_IP_byte_count", Orig_byte_count, sc)
//  val RespPackCount = generateRandomFromFileConditional("Resp_packet_count", Orig_byte_count, sc)






  def generateNodeData(): String = {
    val r = Random

    r.nextInt(255)+"."+r.nextInt(255)+"."+r.nextInt(255)+"."+r.nextInt(255)+":"+r.nextInt(65536)
  }


  /***
    * This function reads a distrobution that is not based on Original Bytes (independent of anything)
    * and picks a number based on the distribution.
    * @param fileContents the contents of one of the files is generated by examining a conn.log file.
    * @return a random number based on a distrobution
    */
  def generateRandNumFromFileDist(fileContents: String): Int =
  {
    val r = new Random
    val numEdgesProb = r.nextFloat()
    var chance = 0.0
    var num = 0
    var strIter = fileContents.split("\n").toIterator
    while(strIter.hasNext && num == 0)
    {
      val line = strIter.next()
      val percentage = line.split("\t")(1).toFloat
      chance = chance + percentage
      if(chance > numEdgesProb)
      {
        if(!line.split("\t")(0).contains("-"))
        {
          num = line.split("\t")(0).split("\\*")(1).toInt //split is a reg expression function so i escape the *
        }
        else
        {
          val firstTabLine = line.split("\t")(0)
          val begin: Int = firstTabLine.split("\\*")(1).split("-")(0).toInt
          val end: Int   = firstTabLine.split("\\*")(1).split("-")(1).toInt
          num = r.nextInt(end - begin) + begin
        }
      }
    }
    num
  }

  /***
    * This function returns a random number but with respect to the number of Original Bytes the connection had.
    * This is to prevent randomly generating bad data such as:
    * Original Bytes: 2GB
    * NumPackets: 2
    * @param fileContents the contents of one of the files is generated by examining a conn.log file.
    * @param byteNum The number of bytes this connection had.
    * @param sc A spark context
    * @return
    */
  def generateRandNumBasedBytes(fileContents: String, byteNum: Long, sc: SparkContext): Long =
  {
    val r = new Random
    val numEdgesProb = r.nextFloat()
    var chance = 0.0
    var num = 0

    val splitFileContents = sc.parallelize(fileContents.split("\n"))
    var text = splitFileContents.filter(record => record.split("\\*")(0).split("-")(0).toLong <= byteNum && record.split("\\*")(0).split("-")(1).toLong >= byteNum)

//    var allStr = ""
//
//    for (aStr <- text.collect())
//    {
//      allStr = allStr + aStr + "\n"
//    }

//    var temp = new FileWriter("temp")
//
//    temp.write(allStr)
//    temp.close()

    var line: String = generateRandStrFromFileDist(text.toLocalIterator)

    val range: String = line.split("\t").head.split("\\*")(1)

    val begin: Int = range.split("-").head.toInt
    val end  : Int = range.split("-")(1).toInt

    return r.nextInt(end - begin) + begin
  }

  def generateRandStrBasedBytes(filename: String, byteNum: Long, sc: SparkContext): String =
  {
    val r = new Random
    val numEdgesProb = r.nextFloat()
    var chance = 0.0
    var num = 0
    var fileIter = Source.fromFile(filename).getLines()
    //    fileIter.next() //we do the next here since the heading is always just text describeing the file


    var file = sc.textFile(filename)
    var text = file.filter(record => record.split("\\*")(0).split("-")(0).toLong <= byteNum && record.split("\\*")(0).split("-")(1).toLong >= byteNum)

//
//    var allStr = ""
//
//    for (aStr <- text.collect())
//    {
//      allStr = allStr + aStr + "\n"
//    }
//
//
//    var temp = new FileWriter("temp")
//
//    temp.write(allStr)
//    temp.close()

    val line = generateRandStrFromFileDist(text.toLocalIterator)

    return line.split("\t").head.split("\\*")(1)
  }

  /***
    *Given a set of of lines pick one at random
    * This function is very similar to generateRandNumFromFileDist
    * but instead of getting a number this function returns the line that it picks
    * @param fileIter: The contents of the file in a string iter
    * @return a weighted random line
    */
  def generateRandStrFromFileDist(fileIter: Iterator[String]): String =
  {
    val r = new Random
    val numEdgesProb = r.nextFloat()
    var chance = 0.0
    var num = 0


    while(fileIter.hasNext && num == 0)
    {
      val line = fileIter.next()
      val percentage = line.split("\t")(1).toFloat
      chance = chance + percentage
      if(chance > numEdgesProb)
      {
        return line
      }
    }
    return null
  }
}

